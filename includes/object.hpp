#pragma once
#include <chrono>
#include <iomanip>
#include <random>
#include <sstream>
#include <string>

#include "defines.hpp"

namespace GeoFrame {
class UUID {
private:
  char mUUID[16] = {0};
  static std::mt19937 sRandomEngine;

private:
  void GenerateUUID();
  UUID(const char *uuid) { M_MEMCPY(mUUID, uuid, sizeof(char) * 16); }
  UUID(const std::string &uuid) {
    M_MEMCPY(mUUID, uuid.c_str(), sizeof(char) * 16);
  }
  UUID &operator=(const UUID &other) = delete;

public:
  UUID() { GenerateUUID(); }
  UUID(const UUID &other) { M_MEMCPY(mUUID, other.mUUID, sizeof(char) * 16); }

  std::string ToString() const;

  bool operator==(const UUID &other) const {
    return M_MEMCMP(mUUID, other.mUUID, sizeof(char) * 16) == 0;
  }
  bool operator!=(const UUID &other) const { return !(*this == other); }

public:
  static UUID FromChar(const char *uuid) { return UUID(uuid); }
  static UUID FromString(const std::string &uuid) { return UUID(uuid); }
};

class Geobject {
protected:
  UUID mUUID;

public:
  Geobject() : mUUID() {}
  virtual ~Geobject() {}

  UUID const &GetUUID() const { return mUUID; }
  virtual Str GetName() const { return mUUID.ToString(); }

  virtual void Delete() {}
};

template <typename T>
concept GeoFamily = std::derived_from<T, Geobject>;

class Tag final : public Geobject {
private:
  Str mTag = "NONE";

public:
  Tag() {}
  Tag(Str const &tag) : mTag(tag) {}
  Tag(Tag const &tag) : mTag(tag.mTag) {}
  ~Tag() { this->Delete(); }

  Str GetName() const override { return mTag; }

  void Delete() override {}

  Tag operator+=(Str const &other);
  Tag operator+=(Tag const &other);

  Tag &operator=(Str const &tag);
  Tag &operator=(Tag const &other);

  bool operator==(Tag const &other) { return mTag == other.mTag; }
  bool operator!=(Tag const &other) { return !(*this == other); }

  operator Str() const { return mTag; }
};

inline Tag operator+(Tag const &tag, Str const &other) {
  return Tag(tag.GetName() + "." + other);
}
inline Tag operator+(Str const &other, Tag const &tag) {
  return Tag(other + "." + tag.GetName());
}
inline Tag operator+(Tag const &tag, Tag const &other) {
  return Tag(tag.GetName() + "." + other.GetName());
}

class ResourceBase : public Geobject {
private:
  M_DISABLE_COPY_AND_ASSIGN(ResourceBase);

protected:
  Str mName;
  Tag mTag;

public:
  static Tag sTag;

public:
  ResourceBase() : mName("NONE"), mTag(sTag) {}
  ResourceBase(Str const &name, Tag const &tag) : mName(name), mTag(tag) {}
  virtual ~ResourceBase() { this->Delete(); }

  virtual Str GetName() const override { return mName; }
  virtual Tag GetTag() const { return mTag; }

  virtual void SetName(Str const &name) { mName = name; }
  virtual void SetTag(Tag const &tag) { mTag = tag; }

  virtual void Delete() override {}
};

template <typename T>
concept ResourceFamily = std::derived_from<T, ResourceBase>;

/*
 * @brief: "Shared" is a wrapper class for pointer.
 * @tparam: T: Type of pointer.
 * @note: This class doesn't delete pointer resource by default. If you want to
 * delete pointer resource, you should call SetDeletable(true) and call
 * Delete().
 */
template <typename T> class Shared : public Geobject {
private:
  bool mDeletable = false;
  T *mPointer = nullptr;

public:
  /*
   * @brief: Default constructor. Nothing to do.
   */
  Shared() : mPointer(nullptr) {}
  /*
   * @brief: Constructor with pointer. Instance that is generated by this
   * constructor delete pointer resource.
   * @param: args: S's constructor arguments.
   */
  template <typename... Args>
  Shared(Args &&...args)
      : mPointer(new T(std::forward<Args>(args)...)), mDeletable(true) {}
  /*
   * @brief: Copy and set reference to other's pointer. Instance that is
   * generated by this constructor doesn't delete pointer resource.
   * @param: other: Other Shared to copy from.
   */
  Shared(Shared const &other) : mPointer(other.mPointer), mDeletable(false) {}
  /*
   * @brief: Move reference of other's pointer. Instance that is
   * generated by this constructor delete pointer resource and other lose its
   * deletability but not lose pointer access.
   * @param: other: Other Shared to move from.
   */
  Shared(Shared &&other)
      : mPointer(other.mPointer), mDeletable(other.mDeletable) {
    other.mDeletable = false;
  }
  /*
   * @brief: Destructor. Nothing to do.
   */
  ~Shared() { this->Delete(); }

  T *GetPointer() const { return mPointer; }

  /*
   * @brief: Get deletability of pointer.
   * @return: Deletability of pointer.
   */
  bool IsDeletable() const { return mDeletable; }

  /*
   * @brief: Delete pointer resource if deletability is set to true.
   */
  void Delete() {
    if (mDeletable) {
      delete mPointer;
      mPointer = nullptr;
      mDeletable = false;
    }
  }
  /*
   * @brief: Cast to Shared<S> from Shared<T>.
   * @return: Shared<S> that has same pointer with Shared<T>.
   */
  template <typename S> Shared<S> Cast() {
    Shared<S> ptr = Shared<S>();
    try {
      ptr = dynamic_cast<S *>(mPointer);
    } catch (std::bad_cast) {
      M_GEO_THROW(KernelError, "Pointer cast failed.");
    }
    return std::move(ptr);
  }

  Shared &operator=(Shared const &other) {
    delete mPointer;
    mPointer = other.mPointer;
    mDeletable = false;
    return *this;
  }
  Shared &operator=(Shared &&other) {
    delete mPointer;
    mPointer = other.mPointer;
    other.mPointer = nullptr;
    mDeletable = other.mDeletable;
    other.mDeletable = false;
    return *this;
  }
  Shared &operator=(T *pointer) {
    delete mPointer;
    mPointer = pointer;
    mDeletable = true;
    return *this;
  }

  T *operator->() const {
    if (mPointer == nullptr) {
      M_GEO_THROW(KernelError, "Resource is expired.");
    }
    return mPointer;
  }
  T &operator*() const { return *mPointer; }

  operator T *() const { return mPointer; }
  operator bool() const { return mPointer != nullptr; }
};
} // namespace GeoFrame

template <> struct std::hash<GeoFrame::UUID> {
  size_t operator()(GeoFrame::UUID const &uuid) const {
    return std::hash<std::string>()(uuid.ToString());
  }
};

template <> struct std::hash<GeoFrame::Tag> {
  size_t operator()(GeoFrame::Tag const &tag) const {
    return std::hash<std::string>()(std::string(tag));
  }
};
